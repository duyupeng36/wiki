# 第 1 章 基本概念

## 1.1 现代 C++

丹麦科学家 Bjarne Stroustrup 于 1985 年发明。到了 1998 年 ISO 颁布了 C++ 的第一个国际标准 ISO/IEC 14882:1998，既是我们常说的 C++98 标准。

几乎所有的应用程序都可以使用 C++ 开发；例如，设备驱动、操作系统、游戏等。C++ 最适合用于编写对性能要求高的应用程序； 例如，需要处理大量数据的应用程序、复杂图形处理的现代游戏、在嵌入式设备和移动设备上使用的应用程序。

> [!tip]
>
> C++ 编写的应用程序的执行效率通常要比其他语言编写的程序快数倍

虽然，C++ 已经被发明许多年了，但是依旧在快速发展，近年来发展速度明显加快。2011 年,ISO发布了C++编程语言的全新版本， 这个版本也被称为 C++11，它使得 C++ 得到复苏。 C++11 深度地现代化了 C++ 语言和我们使用它的方式，**甚至可以将 C++ 当做一门全新的语言**

> [!NOTE]
>
> 使用 C++11 以及更新版本的 C++ 标准进行编程称为 **现代 C++** 编程。现代 C++ 编程并不只是简单使用现代 C++ 标准的新特性。最重要的是， **现代 C++ 编程方法是对良好编程风格达成的共识**。它使用一套指导原则和最佳实践，使 C++ 编程更简单、更安全并且生产效率更高

C++11 标准的出现使得 C++ 社区再次活跃起来，C++ 社区一直努力地扩展和进一步改进 C++。每 3 年，就会发布一个新版本。 在 C++11 之后发布了 C++14、C++17、C++20 以及最新的 C++23

> [!tip]
>
> + C++14 和 C++17 相比较于 C++11 改动较少
> + C++20 的改动就比较大了，它改变了我们使用 C++ 编程的方式
>
> 我们将要学习的就是 C++20 版本

## 1.2 标准库

如果每次编写程序都必须从头开始创建所有内容，就是一件非常枯燥的工作。很多程序都需要相同的功能，例如从键盘上读取数据、数学函数等，C++ 附带了大量预先编写好的代码，因此不需要我们自己编写它们。这些标准代码都在标准库中定义

C++ 带有一个非常大的标准库，其中包含大量例程和定义，提供了许多程序需要的功能。C++ 标准库对于初学者而言是比较困难的。学习 C++ 就像学习开车一样，即使没有赛车需要的专业技能、知识和经验，也可以称为合格、安全的驾驶司机

> [!tip]
>
> 简单来说，标准库就是 C++ 实现附带的预先编写好的代码

## 1.3 C++ 程序概念

下面展示一个完全可以工作的完整 C++ 程序

```cpp
// firstcpp.cpp
// A complete C++ program

import <iostream>;

int main()
{
    int answer {42};

    std::cout << "The answer to life, the universe, and everything is "
            << answer
            << std::endl;

    return 0;
}
```

如下图所示，解释了上述例程的各部分

![1760455763544-d1c183dca2b64702fa726c981fd794af.png](https://cdn.jsdelivr.net/gh/duyupeng36/images@master/obsidian/1760455763544-d1c183dca2b64702fa726c981fd794af.png)

如何执行这个程序呢？首先我们需要使用编译器将其编译为可执行程序，然后才能执行它。这里，我们使用 GCC 编译器来编译我们的程序。由 C++20 之后的标准尚未普及，因编译 C++20 的代码还比较复杂

```shell
# 第一步：首先编译模块。使用 GCC 时，我们必须手动编译 iostream、string、...等模块
g++ -std=c++23 -fmodules-ts -xc++-system-header iostream
# 第二步：编译目标代码
g++ -std=c++23 -fmodules-ts firstcpp.cpp -o firstcpp.exe
```

### 1.3.1 源文件

我们的示例代码是保存在一个名为 `firstcpp.cpp` 的文件中。文件扩展名 `.cpp` 表示这是一个 **C++ 源文件**。源文件包含函数体和程序中大部分可执行的代码

> [!note]
>
> C++ 的源文件通常带有文件扩展名 `.cpp`。此外，还有其他的扩展名；例如 `.cc` `.cxx` 等

最开始我们学习 C++ 时，程序都会比较小，在一个 C++ 源文件中定义就足够了。但是，实际开发中，程序往往由成千上万个文件组成，这些文件并非都是源文件。在大型程序中，会使用其他类型的文件，目的是将程序各个组成部分的接口（函数原型、类定义、模块接口等）从源文件中的实现中分离出来

> [!tip]
>
> 源文件：存储 C++ 实现代码的文件，通常以 `.cpp` 和 `.cc` 作为文件扩展名
>

### 1.3.2 注释和空白

示例代码的前两行是 **注释**。添加注释用于解释程序代码，可以提高可读性，使他人可以更快的理解程序的工作方式。C++ 中，注释使用 `//` 开头，直到该行结束。编译器会忽略一行代码中 `//` 后面的内容

> [!warning]
>
> 注意：不要在每个文件开头的注释中指出文件名。示例代码只是为了演示

C++ 还支持另外一种形式的注释，它可以让注释跨行存放

```cpp
/* This comment is
over two line
*/
```

编译器会忽略 `/*` 和 `*/` 之间的所有内容。这种注释通常用于文档说明

```cpp
/******************\
* This comment is *
* over two line.  *
\******************/
```

**空白** 是空格、制表符、换行符或者换页符等任意序列。编译器会忽略空白，除非由于语法原因需要使用空白把元素区分开来

### 1.3.3 标准库模块

示例代码的第三行 `import <iostream>;` 是一个导入声明，它将 C++ 标准库中的 `<iostream>` 导入到源文件 `firstcpp.cpp` 中，这样，由该模块导出的所有类型和函数都可以在该文件中使用了。在编译之前，几乎在每个文件中都要导入一个或多个标准库模块。

> [!tip]
>
> 请注意：`<iostream>` 也可以作为头文件。实际上，在称为 C++20 的模块之前，它本就是一个头文件。C++20 之前标准库的所有头文件几乎都可以导入 C++20 中，作为模块使用。但是，源于 C 标准库的头文件则不行

### 1.3.4 函数

每个 C++ 程序都至少包含一个函数，通常会包含多个函数。**函数是一个命名的代码块**，执行定义好的操作，例如，读取输入数据、计算平均值或者输出结果。在程序中 **使用函数的名称来执行或调用函数**。程序中的所有可执行代码都放在函数中。C++ 程序中必须有一个名为 `main` 的函数，它是 C++ 程序的执行入口，程序执行总是会从这个函数开始

函数提供了几个重要的有点

+ 程序被分解为不同的函数，更容易开发和测试
+ 一个函数可以在程序的几个不同地方重用，从而降低程序的大小
+ 函数还可以在不同的程序中重用，节省开发时间
+ 大程序通常由不同的程序员共同开发。每个程序员可以负责不同的函数

我们的示例代码 `firstcpp.cpp` 中只包含 `main()` 函数。该函数的第一行是

```cpp
int main()
```

这称为函数头，标识了函数。其中 `int` 是一个类型名称，它定义了 `main()` 函数执行完毕时返回值的类型为整型

> [!tip]
>
> 整数：没有小数部分的数字。例如 23 和 -2048 都是整数，但是 3.1415 和 {% math %} \frac{1}{4} {% endmath %} 不是整数

一般情况下，函数定义中名称后面的圆括号，包含了调用函数时需要传递给函数的信息和说明。函数的可执行代码总是放在花括号（`{}`）中，左花括号跟在函数头的后面

> [!tip]
>
> 函数简单来说就是一个命名的代码块

### 1.3.5 语句

**语句** 是 C++ 程序的基本单元，它总是以分号（`;`）结束。分号表示语句的结束。语句可以定义某个元素，例如计算或者要执行的操作。**程序执行的所有操作都是由语句指定的**。语句按顺序执行，除非某个语句改变了这个执行顺序。例如，`if` 语句。

我们的示例代码中的 `main()` 有 3 个语句。第一条语句定义了一个 **变量**，变量是一个命名的内存块，用于存储某种类型的数据。在示例代码中，变量的名称是 `answer`，可以存储整数值

```cpp
int answer {42};  // 定义变量 answer 存储整数 42
```

类型 `int` 放在名称的前面，指定了变量可以存储的数据类型——整数。注意 `int` 和 `answer` 之间有一个或多个必须得空白字符，用于分隔类型和变量名。如果 `int` 和 `answer` 之间没有空白字符，编译器会把名字看做 `intanswer`，这是编译器无法理解的。`answer` 的初始值放在变量名后的花括号中，所以它最初存储的值是 42。`answer` 和 `{42}` 之间的空格不是必须的。例如，如下几个变量的定义都是有效的

```cpp
int one { 1 };

int two{2};

int three{
    3
};
```

> [!note]
>
> 虽然编译器会忽略多余的空格，但是在编程时应该以统一的风格使用空白字符，以提高代码可读性

可以将多个语句放在一对花括号（`{}`）中，此时这些语句称为 **语句块**。函数体就是一个语句块。语句块也称为 **复合语句**，因此可以将复合语句看做是一条语句。

> [!tip]
>
> 在可以放置语句的任何地方，都可以放置一个包含在花括号中的语句块。因此，语句块也可以放在其他语句块内部，这个概念称为 **嵌套**。事实上，语句块可以嵌套任意级别

### 1.3.6 数据的输入和输出

在 C++ 中，输入和输出是使用 **流** 来执行的。如果要输出消息，可以把消息写入输出流中；如果要输入数据，则从输入流读取。因此，**流是数据源或数据接收器的一种抽象表示**。在程序执行时，每个流都关联着某台设备，关联着数据流就是输入流，关联着数据目的地的流就是输出流

对数据流或者数据接收器使用抽象表示的优点在于，无论流代表什么设备，编程都是相同的。例如，从磁盘文件中读取数据的方式与从键盘上读取是完全相同的

> [!tip]
>
> 在 C++ 中，标准的输出流和输入流分别称为 `cout` 和 `cin`，默认情况下，它们对应计算机的屏幕和键盘

在我们示例程序中的 `main()` 函数中将文本输出到屏幕的语句

```cpp
std::cout << "The answer to life, the universe, and everything is "
          << answer
          << std::endl;
```

名称 `cout` 和 `endl` 在 `<iostream>` 模块中定义。关于 `std::` 前缀稍后介绍。运算符 `<<` 是插入运算符，用于把数据传递到流中。后续我们还会介绍提取运算符 `>>`，它用于从流中读取数据。每个 `<<` 右边的所有内容都会传递到 `cout` 中。把 `endl` 写入 `std::cout`，会在流中写入一个换行符，并刷新输出缓冲区。

> [!tip]
>
> 刷新输出缓冲区可以确保输出立即显示

可以给每行语句添加注释。例如

```cpp
std::cout << "The answer to life, the universe, and everything is "  // This statement
          << answer                                                  // occupies
          << std::endl;                                              // three lines
```

双斜线不必对齐，但是我们通常对齐双斜线，使之看起来更整齐，代码更容易阅读。当然，不应该只是为了写注释而写注释。注释通常应该包含在代码中无法明显看出来的有用信息

### 1.3.7 return 语句

`main()` 函数中的最后一个语句是 `return`。`return` 语句会结束函数，把控制权返回给调用函数的地方。在之前的示例代码中，它会结束函数，把控制权返回给操作系统。`return` 语句可能返回一个值，也可能不返回值。本例的 `return` 语句向操作系统返回 {% math %} 0 {% endmath %}，表示程序正常结束。程序可以返回非 {% math %} 0 {% endmath %} 值，表示不同的异常结束条件。在 `main()` 函数中的 `return` 语句是可选的，可以忽略它。程序如果执行超过了 `main()` 函数中的最后一条语句，就等价于执行 `return 0`

> [!warning]
>
> 只有在 `main()` 函数中，忽略 `return` 才相当于返回 {% math %} 0 {% endmath %}。对于其他任何返回类型为 `int` 的函数，最好以一个显式的 `return` 语句结束，否则编译器不知道任意函数在默认情况下应该返回哪个值

### 1.3.8 名字空间

大项目会同时涉及几个程序员，这样可能会导致名称问题。不同的程序员可能给不同的元素使用相同的名称，这可能会带来混乱，使程序出错。标准库定义了许多名称，很难全部记住。如果不小心使用了标准库名称也会出现问题。名字空间就是用于解决这个问题的

**名字空间类似于姓式**，置于该名字空间中声明的所有名字前面。标准库中的名称都在 `std` 名字空间定义，`cout` 和 `endl` 是标准库中的名称，所以其全名 `std::cout` 和 `std::endl`。其中的两个冒号（`::`）称为 **作用域解析运算符**。这里它用于分隔名字空间中的名字（例如 `cout` 和 `endl`）。名字空间的代码如下所示

```cpp
namespace my_space {
    // All names declared in here need to be prefixed
    // with `my_space` when they are referenced from outside.
    // For example, a `min()` function define in here
    // would be referred to outside this namespace as `my_space::min()`
}
```

花括号对中的所有内容都位于 `my_space` 名称空间中。在 [第 11 章 模块和名字空](./cpp-0x00b-模块和名字空.md) 中介绍

### 1.3.9 名字和关键字

在示例代码中包含变量 `answer` 的定义，并使用 `<iostream>` 标准库模块中定义的名字 `cout` 和 `endl`。程序中的许多元素都需要名称，定义名称的准确规则如下

+ 名字可以是包含大小写字母 `A ~ Z` 和 `a ~ z`、数字 `0 ~ 9` 和下划线 `_` 的任意序列
+ 名字必须以字母和下划线开头
+ 名字是区分大小写的

C++ 标准允许名称的任意长度，但有的编译器对此有某种长度限制，这种限制常常比较宽松，并不严格。大多数情况下，不需要使用长度超过 `12 ~ 15` 哥字符的名称

下面是一些有效的 C++ 名称

```cpp
toe_count   shoeSize    Box
doohickey   Doohickey   number1    x1    y2   pValue    out_of_range
```

**大小写字母是由区别的**，所以 `doohickey` 和 `Doohickey` 是不同的名称。编写由两个或多个单词组成的名称时，遵循几个约定

> [!tip]
>
> + **小驼峰约定**：把第二个以及之后的各个单词的首字母大写
> + **大驼峰约定**：把第一个以及之后的各个单词的首字母大写
> + **蛇形约定**：把每个单词使用下划线（`_`）分隔

**关键字** 是 C++ 中有特殊含义的保留着，不能把它们用于其他目的。例如，`class`、`int`、`namespace`、`throw` 和 `catch` 都是保留字。此外，避免使用如下名字

> [!tip]
>
> + 连续两个下划线开头的名字。例如，`__add`
> + 以一个下划线后跟一个大写字母开头的名字。例如，`_A`
> + 全局名字空间内所有以下划线开头的名字。例如，`_xxx`

虽然使用上述名字编译器并不会报错。但是，问题在于这些名称可能与编译器生成的名称冲突，或者与标准库实现在内部使用的名称冲突。注意，这些保留名称都具备一个特征：**以下划线开头**。

> [!warning]
>
> 请注意：避免使用以下划线开头的名称

## 1.4 类和对象

**类是定义数据类型的代码**。类的名称就是数据类型的名称。类类型的数据项称为 **对象**。创建变量，以存储自定义数据类型的对象时，就要使用类类型的名称。如果定义自己的数据类型，就可以根据具体问题提出解决方案。例如，如果编写一个处理学生信息的程序，就可以定义 `Student` 类型。`Student` 类型可以包含学生的所有特征，例如年龄、性别或学校记录，这些都是程序需要的

## 1.5 模板

有时程序需要几个类似的类和函数，其他代码中只有处理的数据类型有区别。**编译器可以使用模板给特定的自定义类型自动生成类或函数的代码**。编译器使用类模板会生成一个或多个类系列，使用函数模板会生成函数。每个模板都有名称，在想要使用编译器创建模板的实例时，就会使用该名字。

在 [第 10 章 函数模板](./cpp-0x00a-函数模板.md) 和 [第 17 章 类模板](./cpp-0x011-类模板.md) 中介绍模板。在 [第 21 章 受约束的模板和概念](./cpp-0x015-受约束的模板和概念.md) 结束如何通过添加概念表达式使模板的使用更安全、更容易

## 1.6 代码的表示样式和编程风格

代码的编排方式对于代码的可读性有非常重要的影响。这有两种基本的方式。首先，可以使用 **制表符** 或者 **空格** 缩进程序语句，显出这些语句的逻辑；再以一致的方式使用定义程序块的匹配花括号，使程序块之间的逻辑更清晰。其次，可以把一个语句放在两行或多行商，提高程序的可读性

通常，我们采用如下的样式

```cpp
namespace mine 
{
    bool has_factor(int x, int y)
    {
        int factor { hcf(x, y) };
        if (factor > 1)
        {
            return true;
        }
        else
        {
            return false;
        }
    }
}
```

或者

```cpp
namespace mine {
    bool has_factor(int x, int y) {
        int factor { hcf(x, y) };
        if (factor > 1) {
            return true;
        } else {
            return false;
        }
    }
}
```

> [!tip]
>
> 可以根据自己的喜好和公司要求组织代码形式

## 1.7 创建可执行程序

从 C++ 源代码中创建可执行的模块通常需要三个步骤。

+ 第一步：预处理器处理所有预处理指令。一般来说，它的关键任务之一就是将所有 `#include` 头文件的完整内容复制到源文件中。但是，由于 C++20 中引入的模块将被淘汰
+ 第二步：编译器把每个源文件转换为对象文件，其他包含了与预处理代码对应的机器码
+ 第三步：链接器把程序的二进制文件合并到包含完整可执行程序的文件中

下图演示了 {% math %} 3 {% endmath %} 个源文件经过编译后，生成 {% math %} 3 {% endmath %} 个对应的对象文件。由于标识对象文件的文件扩展名在不同的机器环境中不同，因此没有显示。

![1760538078568-4a24cc47543c5840001f3dec666c3ce1.png](https://cdn.jsdelivr.net/gh/duyupeng36/images@master/obsidian/1760538078568-4a24cc47543c5840001f3dec666c3ce1.png)

组成程序的源文件可以在不同的编译器运行期间单独编译，但大多数编译器都允许在一次运行期间编译它们。无论采用哪种方式，编译器都把每个源文件看做一个独立的实体，为每个 `.cpp` 文件生成一个对象文件。然后在链接步骤中，把程序的对象文件和必要的库函数组合到一个可执行文件中

## 1.8 过程化编程和面向对象编程

历史上，过程化编程是编写几乎所有程序的方式。要创建文件的过程化编程解决方案，必须考虑程序实现的过程，才能解决问题。一旦需求明确地确定下来，就可以写出完成任务的大致提纲

+ 对程序要实现的整个过程进行清晰的说明
+ 将整个程序分为可工作的计算单元，这些计算单元应尽可能自包含的。它们常常对应于函数
+ 根据正处理的数据的的基本类型来编写函数

在解决相同问题时，面向对象编程方式除了开始时对问题进行清晰说明这一相同点之外，其他地方完全不同

+ 根据问题的详细说明确定该问题所涉及的对象类型。例如，程序涉及棒球运动员，就应该把 `BaseballPlayer` 标识为程序要处理的数据类型。如果程序是一个会计程序包，就应该定义 `Account` 类型和 `Transaction` 类型的对象。还要确定程序需要对每种类型执行的操作集合。这将生成一组与应用程序相关的数据类型，用于编写程序
+ 为问题需要的每种新数据类型生成一个详细的设计方案，包括可以对每种对象类型执行的操作
+ 根据已定义的新数据类型及其允许的操作，表达程序的逻辑

面向对象解决方案的程序代码完全不同于过程化解决方案，理解起来也比较容易，维护也方便得多。面向对象解决方案所需要的设计时间要比过程化解决方案长一些。但是，面向对象程序的编码和测试阶段比较短，问题也比较少，所以这两种方式的整个开发时间大致相同

下面简单介绍面向对象编程方式。假定要实现一个处理各种盒子的程序。这个程序的一个合理要求是把几个小盒子装到另一个大些盒子中。在过程化程序中，需要在一组变量中存储每个盒子的长度、宽度和高度。包含几个盒子的新盒子的尺寸必须根据每个被包含盒子的尺寸，按照为打包一组盒子而定义的规则进行计算

面向对象解决方案首先需要定义 `Box` 数据类型，这样就可以创建变量，引用 `Box` 类型的对象，并创建 `Box` 对象。然后定义一个操作，把两个 `Box` 对象加在一起，生成包含前两个 `Box` 对象的第三个 `Box` 对象。使用这种操作，就可以编写如下语句

```cpp
bigBox = box1 + box2 + box3;
```

> [!tip]
>
> 这只是一个简单的说明，后续会相信介绍面向对象编程

## 1.9 表示数字

在 C++ 程序中，数字的表示有许多方式，所以必须理解表示数字的各种可能性。

### 1.9.1 二进制

要理解二进制，我们首先考虑常见的十进制数（例如 324 或 911）表示什么。在十进制数中

+ 324 是 {% math %} 3 \times {10}^{2} + 2 \times {10}^{1} + 4 \times {10}^{0} {% endmath %}。也就是 {% math %} 3 \times 100 + 2 \times 10 + 4 \times 1 {% endmath %}
